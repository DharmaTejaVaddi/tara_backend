from django.shortcuts import render
from rest_framework import status
from rest_framework.response import Response
from rest_framework.decorators import api_view
from .serializers import UserRegistrationSerializer
from password_generator import PasswordGenerator
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from rest_framework.views import APIView
import traceback
from django.db import DatabaseError, IntegrityError
from django.contrib.auth.tokens import default_token_generator
from django.utils.http import urlsafe_base64_decode, urlsafe_base64_encode
from django.core.mail import send_mail
from django.contrib.auth import get_user_model
from django.conf import settings
from .models import User
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.decorators import api_view, permission_classes
from rest_framework.exceptions import ValidationError
from rest_framework_simplejwt.tokens import RefreshToken


def Autogenerate_password():
    pwo = PasswordGenerator()
    return pwo.shuffle_password('abcdefghijklmnopqrstuvwxyz', 8)  # Generates an 8-character password


# User Registration
@swagger_auto_schema(
    method='post',
    request_body=UserRegistrationSerializer,
    responses={
        201: openapi.Response("User registered successfully"),
        400: openapi.Response("Bad Request"),
        500: openapi.Response("Internal Server Error")
    },
    operation_description="Handle user registration. Sends an email with an activation link."
)
@api_view(['POST'])
@permission_classes([AllowAny])
def user_registration(request):
    """
    Handle user registration with autogenerated password if not provided.
    """
    if request.method == 'POST':
        try:
            request_data = request.data
            request_data['email'] = request_data['email'].lower()
            serializer = UserRegistrationSerializer(data=request_data)
            if serializer.is_valid():
                user = serializer.save()
                token = default_token_generator.make_token(user)
                uid = urlsafe_base64_encode(str(user.pk).encode())
                activation_link = f"{settings.FRONTEND_URL}/activate/{uid}/{token}/"

                send_mail(
                    subject="Activate your account",
                    message=f"Activate your account using the link: {activation_link}",
                    from_email=settings.EMAIL_HOST_USER,
                    recipient_list=[user.email],
                )
                return Response({"message": "User registered. Check your email for activation link."},
                                status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except IntegrityError:
            return Response({"error": "A user with this email already exists."}, status=status.HTTP_400_BAD_REQUEST)
        except DatabaseError:
            return Response({"error": "Database error occurred"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        except Exception as e:
            return Response({"error": "An unexpected error occurred.", "details": str(e)},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)


# Activate User

class ActivateUserView(APIView):
    """
    View for activating user accounts using UID and token.
    """

    @swagger_auto_schema(
        manual_parameters=[
            openapi.Parameter(
                'uid', openapi.IN_PATH, description="User ID (Base64 encoded)", type=openapi.TYPE_STRING
            ),
            openapi.Parameter(
                'token', openapi.IN_PATH, description="Activation token", type=openapi.TYPE_STRING
            )
        ],
        responses={
            200: openapi.Response("Account activated successfully"),
            400: openapi.Response("Invalid or expired activation link"),
        },
        operation_description="Activate user account using UID and token."
    )
    def get(self, request, uid, token):
        """
        Handle user account activation.
        """
        try:
            uid = urlsafe_base64_decode(uid).decode()
            user = User.objects.get(pk=uid)
        except (ValueError, TypeError, User.DoesNotExist):
            return Response({"message": "Invalid activation link"}, status=status.HTTP_400_BAD_REQUEST)

        if default_token_generator.check_token(user, token):
            user.is_active = True
            user.save()
            return Response({"message": "Account activated successfully"}, status=status.HTTP_200_OK)

        return Response({"message": "Invalid or expired token"}, status=status.HTTP_400_BAD_REQUEST)


# Test Protected API

class TestProtectedAPIView(APIView):
    @swagger_auto_schema(
        operation_description="Test protected endpoint",
        responses={
            200: openapi.Response("Success", openapi.Schema(type=openapi.TYPE_OBJECT, properties={
                "message": openapi.Schema(type=openapi.TYPE_STRING)
            })),
            403: openapi.Response("Forbidden")
        }
    )
    def get(self, request):
        """
        Protected endpoint for authenticated users.
        """
        return Response({
            'message': 'You have access to this protected view!',
            'user_id': request.user.id,
            'email': request.user.email
        })


# Forgot Password
class ForgotPasswordView(APIView):
    permission_classes = [AllowAny]

    @swagger_auto_schema(
        request_body=openapi.Schema(
            type=openapi.TYPE_OBJECT,
            properties={
                'email': openapi.Schema(type=openapi.TYPE_STRING, description='Email address'),
            }
        ),
        responses={
            200: openapi.Response("Reset link sent if the email exists"),
            400: openapi.Response("Bad Request")
        },
        operation_description="Send a password reset link to the user's email."
    )
    def post(self, request, *args, **kwargs):
        """
        Handle forgot password functionality.
        """
        email = request.data.get("email")
        if not email:
            raise ValidationError("Email is required.")
        try:
            user = User.objects.get(email=email.lower())
        except User.DoesNotExist:
            return Response({"message": "If an account exists with this email, you will receive a reset link."},
                            status=status.HTTP_200_OK)

        token = default_token_generator.make_token(user)
        uid = urlsafe_base64_encode(str(user.pk).encode())
        reset_link = f"{settings.FRONTEND_URL}/reset-password/{uid}/{token}/"

        send_mail(
            subject="Reset Your Password",
            message=f"Click on the following link to reset your password: {reset_link}",
            from_email=settings.EMAIL_HOST_USER,
            recipient_list=[user.email],
        )

        return Response({"message": "If an account exists with this email, you will receive a reset link."},
                        status=status.HTTP_200_OK)


# Reset Password
class ResetPasswordView(APIView):
    permission_classes = [AllowAny]

    @swagger_auto_schema(
        request_body=openapi.Schema(
            type=openapi.TYPE_OBJECT,
            properties={
                'password': openapi.Schema(type=openapi.TYPE_STRING, description='New password'),
            }
        ),
        manual_parameters=[
            openapi.Parameter('uid', openapi.IN_PATH, description="User ID", type=openapi.TYPE_STRING),
            openapi.Parameter('token', openapi.IN_PATH, description="Reset Token", type=openapi.TYPE_STRING)
        ],
        responses={
            200: openapi.Response("Password has been successfully reset"),
            400: openapi.Response("Invalid reset link or expired token"),
        },
        operation_description="Reset user's password using token and UID."
    )
    def post(self, request, uid, token, *args, **kwargs):
        """
        Reset user password.
        """
        password = request.data.get("password")
        if not password:
            raise ValidationError("Password is required.")
        try:
            uid = urlsafe_base64_decode(uid).decode()
            user = User.objects.get(pk=uid)
        except (User.DoesNotExist, ValueError, TypeError):
            return Response({"message": "Invalid reset link"}, status=status.HTTP_400_BAD_REQUEST)

        if default_token_generator.check_token(user, token):
            user.set_password(password)
            user.save()
            return Response({"message": "Password has been successfully reset."}, status=status.HTTP_200_OK)
        return Response({"message": "Invalid or expired token"}, status=status.HTTP_400_BAD_REQUEST)


# Refresh Token
class RefreshTokenView(APIView):
    permission_classes = [IsAuthenticated]

    @swagger_auto_schema(
        request_body=openapi.Schema(
            type=openapi.TYPE_OBJECT,
            properties={
                'refresh': openapi.Schema(type=openapi.TYPE_STRING, description='Refresh token'),
            }
        ),
        responses={
            200: openapi.Response("New access token generated"),
            400: openapi.Response("Invalid refresh token"),
        },
        operation_description="Generate a new access token using a refresh token."
    )
    def post(self, request, *args, **kwargs):
        """
        Refresh the access token using the refresh token.
        """
        refresh_token = request.data.get("refresh")
        if not refresh_token:
            return Response({"detail": "Refresh token is required."}, status=status.HTTP_400_BAD_REQUEST)

        try:
            token = RefreshToken(refresh_token)
            new_access_token = str(token.access_token)
            return Response({"token": new_access_token}, status=status.HTTP_200_OK)
        except Exception:
            return Response({"detail": "Invalid refresh token."}, status=status.HTTP_400_BAD_REQUEST)

